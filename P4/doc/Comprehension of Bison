Introduction:
bison是一个通用目的的语法分析产生器，可产生一个确定的LR语法或一个使用LALR分析表的普遍的LR分析器。

Bison Grammar Files:
之前大致看过了所有的.y文件，也大体的了解了它的一个结构，现在重新将这个结构拿出来(来自Bison manual)：
%{
Prologue
%}

Bison declarations

%%
Grammar rules
%%

Epilogue
以上就是Bison的大体框架，我们在自己写.y文件的时候就按照这样的格式来写。下面分别介绍一下每一个部分：

Prologue部分是一些宏，函数及变量的声明，以及头文件的引用。大致就像是C语言中的#...之类的东西一样。当然它的用法和扩展有很多，到用到的时候再去考察，在此不继续说明。

Bison declaratinos部分包括了终结符以及非终结符的定义，以及优先级的定义等等。下面我们通过结合.y文件来了解已经被用到的一些定义，以及每个定义所代表的含义。
%union：这个的定义以及含义就如C中union的一样
%token：这个符号非常的重要，它是定义一个终结符，这个定义在形成分析器的时候会转换为#define的形式(这个会在我们理解Bison所生成文件的时候看到)，并且这个所定义的终结符与yylex中定义的名字相对应，以此与.lex构成一定的联系。当然也可以用这个记号去定义一些常数。当然此记号还有很多用法，我们在用到的时候再去了解。
%left,%right：这个其实是%token的一种特殊的形式，它专门用于定义运算符的结合性以及优先级。
%type：这个记号用来定义非终结符，然后每个非终结符的类型可以由union定义的一些类型来定义。当然此记号也可以定义终结符，和任何token中定义的符号，但一般来说我们是去定义非终结符。
%location：这个记号是用来产生程序的位置，它用来对应一些符号的位置，比如"@n"之类的，还可以用来准确的确定语法错误的信息。
%debug：这个记号有点像是一个跟踪器，主要是用于分析器的跟踪调试的。

Grammar rules这个部分包含了语法规则和一些用法。里面的语法规则就是我们书上所讲的一些规则，大体上都差不多，下面我会将那些比较特别的东西拿出来进行说明。
Action：我将其理解为语法动作。每一个Action都是跟在一个语法规则的后面，用来指明当遇到这种语法规则的时候我将要进行什么样的一种操作。通常情况下它是放在每一个语法规则结束之后，但是有一些Action是放在语法规则中的。而这样的一些Action的执行是在扫描完它之前的符号就立刻执行，而不需要等整条规则都扫描完成之后进行执行。它实际上就是边扫描边做的这样一种形式。我看了一下config中所有的.y文件，都没有这样的一种情况，所以就不再进行深入的理解的，大致了解有这么一个东西就行了。Action还有一个作用就是去描述分析器的输出行为，这个与loction有关。
Symbol：这里所要理解的symbol与之前的那些终结符和非终结符不同，但是它们之间却有着很密切的关系。就如一些符号"$$"这类的，我将比较详细的去介绍和理解这些符号的含义以及用法，因为这写符号非常广泛的用于Action中，并且与location相关联，有很大的用处。
1.@$：它的属性是variable，它代表了n个成分中最左边的一个成分的位置。
2.@n：它有两个属性，一个是variable，一个是symbol。当它在action时，它代表的时n个成分中从左到右的第n的成分的位置(还有点问题有待考察)；当它是grammar时，暂不说明。
3.@name(@[name])：它的属性是variable，它通过此名称来确定位置，代表了此名称所代表的那个符号名所在的位置。
4.$@n：它的属性是symbol，它处在grammar中，暂不说明。
5.$$：它的属性是variable，它代表了规则中的最左边的那个符号。
6.$n：它的属性是variable，它代表了规则中从左到右的第n个符号。
7.$name($[name])：它的属性是variable，它代表了规则中这个名称所代表的符号。

Epilogue这个部分是分析器实现的一部分，我们可以将任何我们想在分析器中实现的东西放入此位置，当然最常用的是yylex和yyerror这两个东西。并且这两个东西在我们C0的设计上有很重要的地位。那么我们来了解一下Parser C-Language Interface以便更好的完成C0的实现。主要说明yyparse()(分析器的最主要的接口)，yylex()以及yyerror()，我们还是用到什么说什么。首先时yyparse()这个函数是触发分析的开始，引用这个函数就能开始对这个文法进行分析。yyparse()它返回的是一个整型值，返回0表示成功分析，返回1表示语法错误发生，返回2表示内存超出。所以我们要判断是否分析正确完成，我们只需要查看返回值即可。下面介绍yylex()，通过仔细查看.y文件，我们会惊奇的发现，在.y文件中似乎并没有使用到.lex文件中的东西，那我们是怎么样将分析出来的词法拿给语法分析去使用的呢？首先我们必须清楚，Bison是不会自动生成.lex文件的，也就是它只会做语法分析，所以词法分析需要我们自己通过flex进行描述。那语法分析是怎么调用的呢？其实这个是使用Bison时，使用"-d"操作来实现的。我们去查看.lex文件，我们会发现，它在开头的时候包含了这样一个头文件".tab.h"，这个文件是Bison生成的(使用"-d"操作生成的.tab.h文件)。这个文件包含了一些宏定义，这些定义在.y和.lex中是一致的。我们去看makefile的时候会发现，我们实际上是先使用Bison再使用flex的，因为.lex文件中的".tab.h"需要通过Bison先生成出来。这就形成了词法与语法的联系。yylex()返回的一系列的标识符都是一些正整数值，这些值就在所引用的".tab.h"中定义的，但是我们现在还是没有解释语法分析是如何调用已经扫描过的词法分析的东西。我们先make expr，打开所生成的".tab.c"，我们可以搜索到yylex的位置，在这里面它定义了YYLEX实际上就是yylex，而通过将yylex的值赋值给yychar就将.lex中定义并且在词法分析中分析到的词法传递给了语法分析，然后语法分析只需要使用yychar就可以开始进行语法分析了。我们继续看".tab.c"中最核心的部分yyparse()，我们主要注意一下函数中的一个switch和case语句，这里面有9中情况，这9种情况分别对应了.y文件中的9个Action。但是至此总感觉有flex和bison生成的这两个文件还是没有特别好的联系起来，这个时候我们就看一下makefile，在makefile中最后生成可执行文件是通过同时编译这两个文件最终形成一个可执行文件，就相当与在最后链接的时候将这两个文件链接到了一起，最后一起生成了目标文件，这样子就将这两个文件很好的联系起来了。最后我们来看看yyerror()。这个函数就是一个错误信息处理函数，当在语法分析的过程中遇到错误的时候，就会调用此函数来报错。之后便会返回yyparse()，如果有错误恢复系统，那么就会进行相应的错误恢复，否则就直接返回1跳出。对于错误恢复，需要我们自己去实现。

最后一个东西：关于语言文法对生成的分析器的分析表状态空间的影响。这个我找到了bison manual中的memory management。在这个内容中，我了解到，如果有过多的符号需要移进而没有归约那么就会产生内存越界的情况，因为bison使用的是一个栈来进行语法分析的，所以如果过多的符号进入栈，必然会出现栈溢出的情况。所以语言文法的设计非常的重要，既要从形式上把握，也要从数量上去把握。形式上，让归约动作尽可能的多，以保证栈不会溢出；数量上，符号尽量的少，也能从每种意义上防止栈溢出的发生。

以上就是对Bison的大体理解。

Made By 王一橙

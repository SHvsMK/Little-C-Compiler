这个文档大致写一下我整个实验中所思考的一些东西和遇到的一些问题。

这个实验的代码部分我在实验一布置下来我就完成了，之所以能有动力在实验一布置下来就将其完成也是因为有一位同学他很早就完成了，所以就自然就有了东西，之后就基本上就没有怎么再看实验了，到了要提交实验的这两天，当有别的同学问到我关于调试方面的问题的时候，我才再次开始看这个实验中的一些内容，以及总结一下这个实验中的东西。
实验主要完成的部分分为两个，一个是AST，一个是Symbol Table，实验的要求是在给的例子中的这两部分上去扩展内容，我便重新阅读理解了AST与Symbol这两个部分，大致的理解也写在了同一目录下的"对AST以及Symbol的进一步理解与说明"中。这里我就不再赘述。

首先是AST的设计，这个部分的设计其实方法和原理是很简单的，只要去根据语法，去构造一个AST，然后对节点进行递归的构造就可以了，其本质就是构造一个多叉树，没有什么困难的地方。大致的代码部分就参看config/C0*.y。你可以看到里面有很多的.y文件这个我会在后面解释。这些都不是没有用的东西，不过只需要看C0.y程序就可以了，因为别的只是在这个文件上的一些修改，可以这么说，是不同的版本吧，但是它们在使用某些方法上有不同，主要是符号表的不同，具体放在后面说明吧。继续说AST的构造。首先我是在common.h中定义了AST节点的大致的结构，每一个结点有3个域，一个是类型域，因为我们知道语法中的非终结符和终结符是各种各样的，所以我们为了方便就设计一个结点，它能让所有非终结符和终结符共用，那么我们如何知道它代表了什么形式的非终结符和终结符了？所以我们在结点中引入kind这个枚举类型来标志类的种类；第二个是结点中不同类型所对应的结点，或者我觉得可以把其称作为方法，它是写为共用体形式的。比如说，在我的结点中有这样一个类型KProgram这是程序最开始的第一个结点，当我在构建结点把其类型值赋为KProgram时，我就使用其中的pro这个节点，这是一一对应的，然后至于pro它的类型，我们会去重新定义，根据它的具体位置和功能去定义它；第三个是loc，这是用来记录AST结点所对应的源程序的位置的。这样我们就把基本的结点信息定义了，但是之前的第二个域中每一个不同的方法，我们暂且这么说，我们还要去定义这些方法，所以我们就根据不同的方法去写了不同的类型，比如前面的pro，它是由Pro定义的，那么Pro是怎样的了？它是一个包含5个astnode的结点的一个指针，它的每一个kids都指向由Program所推导出的语法中的会继续深入下去推导的结点。这样所起来有点抽象。我们看下面的例子：Program	: CDecl IntDecl VDecl mainsym lparen rparen lbrace IntDecl Stmt rbrace。这是在说，冒号右边的东西会归约成左边的Program，那么当右边的东西都处理完之后，我会以Program创建一个结点，它的类型时KProgram，然后它有一个域为Pro定义的pro，pro有5个孩子，分别指向CDecl，IntDecl，VDecl，Intdecl，Stmt。大致就是这个样子。在设计完了基本的结构就开始设计构造函数了，首先我在common.h中声明了构造函数有哪些，具体见common.h，然后每一个构造函数的定义在ast.c中，然后每一个构造函数的具体内容与实现就是根据不同的语法来实现的，具体就参见ast.c。然后还有一个dumpAST这样一个函数，这个函数是在构造完成整个AST之后通过遍历输出整个源程序。AST的内容大致就是这些。

下面是Symbol的设计，在说Symbol这部分的设计之前，需要首先说明一些东西，也就是我之前提到的在我的config文件中为何有这么多的.y和.lex，它们到底是做什么的了？首先是C0.y和C0.lex这个版本，是我最初的设计版本，它没有用到符号表，我在遇见ident的时候直接是将其处理为结点信息，在一些需要对ident进行处理的结点中用char *name来直接存储ident的内容，然后就没有用到Symbol，因为最开始觉得如果只是构造AST没有必要使用符号表，然后是C01.y和C01.lex，这个版本中我使用了Symbol，但是这个是直接使用老师在例子用的Symbol表，没有任何修改，直接将其接口应用到我的AST中，最后一个是C02.y和C02.lex，这个中使用到的Symbol是我自己设计的，因为我觉得老师的那个Symbol表中结构不是特别清晰，而且在以后我要用Symbol的时候，我如果要扩展或者遇到一些问题的时候可能会更加方便一些，毕竟是我自己设计的Symbol表，用起来肯定更顺手一些，就是基于这个我才自己又设计了一个自己的Symbol表。然后对于上面的不同的版本，我有不同的common*.h,ast*.c,symbol*.c具体内容参见具体的文件，这里就不再赘述。现在主要说下我的符号表的设计，我的符号表就是一个简单的链表，这没有进行什么样的优化，每次遇到新符号就添加进去，然后搜所的时候就顺序收缩，然后没有个符号表结点的内容主要是name，而其他的功能可以自行扩展，根据以后分析的需要进行不同内容及功能的扩展，具体的声明看common*.h，具体的定义和实现看symbol*.c中的内容，在此不再赘述。

下面我说一下我在编译和调试的过程中遇到的一些问题和解决方法，因为从最初编写这个程序到现在过了很长的时间，有些东西记忆也不是特别的清楚，我就有什么说什么。之前本来想在写的过程记录的，但是感觉那样做很是拖沓，就是感觉写代码不太顺畅，所以就没有那么做了。

首先说一下我在.y文件中加入的那个debug，这个是用来编译完成运行是输出便于我调试的东西，我是直接用的老师写的那个，#define debug(a) printf("%s", a)，但是我最初的时候什么东西都输出不了，也不知道为什么后来改成这个样子
#define debug(a) printf("%s\n", a)就有输出了，这个问题是关于缓冲区的问题，要输出的内容先进入缓冲区，如果缓冲区没有填满但是程序又出错，这个时候就没有输出，所以加上"\n"就解决了这个问题。下面是关于使用老师的symbol所遇到的问题，我一开始不知道为什么老是没法用老师的symbol，只要用到这个的时候，就会出现段错误，这也是我为什么一开始就直接没有用符号表的原因，但后来又用了老师的symbol又没有问题了，所以我也不太清楚当时错误出在什么地方了。然后是.lex中的修改，之前我在没有修改.lex时，每次的遇到number和name都是0和null，后来发现是因为没有返回值的问题，所以在.lex中加入了yylval这样的变量来传递值，这样就解决了问题。接下来是编译所遇到的问题，也就是各种头文件的问题，什么顺序啊之类的，最主要的是，要将.lex中的两个头文件引用,common.h要放在C0.tab.h的前面，这个非常重要。还有一个就是左值问题，上课的时候老师提到了要处理左值问题，但是我觉得只要对语法进行适当的设计就不会出现要判断左值右值的问题。

大致的说明就是这些了吧。其余的就看看程序了。

Made By SHvsMK
PB11011030

本文档是对pl0编译器中使用的符号表的理解：
1.组织结构，如下
struct{
    char name[al+1];
    enum object kind;
    long val;
    long level;
    long addr;
}table[txmax+1];
这是一个结构体，txmax时符号表的上限所能保存的符号
name是存储符号的名称
kind是存储符号的类型，有变量，常量，过程
val是存储的常量和变量所被赋予的值
level是指的是当前所在的层次，用于变量和过程，记录他们当前的层次，为限制函数层次过多
addr是指变量所保存的地址，即数据所被分配的地址，也用于显示变量的位置

2.position()：
这个函数的调用是当遇到表达式时，如果变量出现在左端，有此函数先查看该变量是否定义了，然后如果定义了准备下面的工作，如果变量出现在右端，则通过这个函数查看变量是否定义，然后确定变量并之后引用变量的值，当遇到call命令时，需要函数检查这个过程是否定义过，保证call的合法性。此函数在于确定标识符的定义，以及确定是哪个标识符。

3.标识符的插入，查找，删除：
插入：首先会判断定义该标识符是变量，常量还是过程然后通过不同的种类，将种类传入enter函数，通过strcpy()将标识符加入table中，并且针对不同的种类，修改table中的不同的参数。比如对于const只需要对val参数进行修改。这样就在table表中添加进了这个标识符。
查找：查找就是通过position()函数进行查找，它就是通过遍历所有的table中的内容，注意它遍历的顺序是从后往前的，这也就可以解释，为什么同一个标识符我们在多次定义了之后它只选择我们最后定义的那个值。这一个方面可以解决层次的问题，也就时全局变量和局部变量的问题，全局变量在局部的时候，先考虑局部变量。其实为了解决冲突，也就是解决重复的定义只需要对table中的多个项目进行对比，然后如果所比较的项目都是一样的，那么就可以表明它是重复定义，我们就应该报错。并且只引用最开的定义，而不将后面的定义添加进table表中。
删除：其实从空间上标识符一直在表中，知道有别的标识符将其占用。删除过程其实只存在与进入一个过程的时候定义了一个相同标识符的变量，然后从过程中出来的时候，我们就不能用过程中定义的那个变量了，程序所做的操作只是在进入和出来是的表的大小，用tx1记录tx当前为进入下一层时的值，当回到当前层的时候，还原tx的值，那么在过程中所定义的所有变量就像没有定义一样。从空间上没有消失，但是从逻辑上已经不存在了。这就是它的删除操作。

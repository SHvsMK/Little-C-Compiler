在介绍这个实验之前有两点说明。
1.修改了一个错误的地方，就是在生成表达时的一个错误。再dump语法为TM的语法时，dump的顺序的改正。
2.去掉了原有的else的语句，为了使生成的代码更加简单(但会在综合实验的时候重新加入else语句)

下面开始介绍我在写整个实验的一个思路。
大致有一下几点(我只是描述一些重点的内容，不会去细细讲解每一个语法为什么要生成这样的语句，因为有些东西是显然易见，我觉得只需要看ast.c的源代码就可以很好的理解)
1.需要开的空间的确定
因为在进入一个函数，或者一开始的时候，我需要知道要开多少空间，那么我就需要去统计变量的个数，所以我给相应结点添加了一个新的域，alloc。而这些相应的结点是整个大的Program的那个结点，还有与主函数相关的结点，以及每个函数的结点。它记录的是每一段所需要的空。然后我如何去记录的了？我就在第一次生成语法树的时候，递归的去获得当前段所需要的空间数。
举个例子说明：
对语法Program说明，
Program	: CDecl IntDecl VDecl mainsym lparen rparen lbrace IntDecl Stmt rbrace
这就相当于我总的程序的框架，它的层次是第0层，那么我一开始运行的时候就要确定好全局变量的个数，然后开出相应的空间，那么我怎么知道全局变量有多少个了？我通过结构发现，其实它的个数就等于CDecl中定义的常量的个数加上IntDecl中定义变量的个数。(在此我先声明一下，我其实也为常量定义了空间，把它当成一个不能改变值的变量来进行处理，在遇见常量时不是去寻找符号表对应的信息，而去访问相应的空间，我这样写是为了方便我在函数内部定义常量时的理解，我觉得这样写，更好理解整个程序的运行。当然我也可以不为它开出空间而直接在符号表中去取得相应的信息。这是一个小小的说明。)所以，我只需要计算出CDecl的个数和IntDecl的个数，然后加起来就是Program的个数，而CDecl和IntDecl的个数是多少，我同样时递归的去做，根据它们不同的结构去计算它们的个数，所以就这样递归的一层一层的做下去，其实就是一个综合属性的计算。不过最后要记住，最后多开3个空间，为了存储返回信息以及层次信息，这一点我在“对PCode的重新认识及理解”中有详细的说明。

2.然后是每一段语法所对应PCode程序的生成，其实这个并没有什么太多好说明的，只要更具C0的意思，将其翻译成PCode中对应的意思就可以了，大致就如同“old_pl0project”文档中代码生成那一部分的内容一样，但是单单是将每一条C0中的语法翻译成相应的PCode中的语言是不够的，还需要加入一些跳转语句，来保证程序的正常跳转与执行，主要是函数的跳转，如果没有函数，只有一个主函数，那基本上就是一句一句的翻译就可以了。因为函数在主函数之前，而我一开始运行的时候，先是初始化常变亮，然后就进入主函数，那么因为其他函数在主函数之前，那么我就需要有一个跳转语句来执行相应的跳转，让它跳转到主函数的入口，我采用的方式最开始是在定义完常变量之后直接跳转至主函数入口，后来我将其修改为，直接顺序执行，但是每遇到一个函数就直接跳转到该函数的出口，我觉得这样做的好处，是可以从一个抽象层次上更好的理解一个问题，就是我在运行主函数以前其实其他函数的内容都已经生成好了，而它们的执行都取决与主函数是否直接或间接的引用。可能说明得不是特别清楚，我也是为了加深我对整个流程的理解，才将其改为这个样子的。其实就好像是，我通过访问每个函数头就将其加入了符号表，我就知道这个函数存在，而不至于在主函数直接或间接引用时找不到这个函数。

3.回填技术，因为在有时候在生成调用代码cal时，一开始并不知道要转移到什么位置去，只有转移地址之前的代码都生成完之后，才可以确定转移地址，所以我们就将这个cal所在的代码段的地址记录下来，然后在其他代码生成完毕之后，可以知道转移地址的时候，在重新填写cal中所要转移的地方，这样就很好的解决了问题。

4.2次代码生成。这是我在生成代码时没有想到一个好的解决方案所采取的一个方法。如果在两个函数相互调用的时候，我前面的函数调用后面的函数时，我并不知道后面的函数的地址。那么如何去确定它的地址成了一个问题，如果在生成第一个函数的时候，直接去符号表中第二个函数的地址，会出错，因为第二个函数还没有生成出来，所以就出现了问题。最开是我打算去使用回调技术去处理这个问题，后来我发现这样做并不容易，因为我语法设计的问题，我是进入了函数之后，Stmt这一部分包含了函数引用。比如有这样一条语句a()，表示要引用a这个函数，而a函数的定义在后面，此时我照常的去查找符号表填入cal的信息，然后就出错了。而如果回调的话，我就需要在遇到这样的语句的时候去判断这里引用的函数是否已经定义过了，如果没有定义，那么在后面定义的时候就要对这里的cal进行回填地址。这时候就会出现麻烦，我在什么地方去回填地址，如果有很多这样的语句怎么办。这里用回填，和我在第3点中讲的回填所遇到的环境是不同的，第3点中遇到的环境可以很好的使用回填技术，因为结构的问题。而这里的结构使得回调技术变得有些麻烦，或许是我自己没有找到一个更好的方法去处理，所以我就采用了我自己发明的2次代码生成的技术，我第一次先生成代码，第二次在生成一次代码，这样第二次的时候，符号表已经在第一次中完整的建立好了，地址信息都是正确的，这个时候我去查找就不会出现问题，不过这样的问题时，效率会非常的低。此时我不得不感慨，完成目的就是最好的，正所谓，白猫黑猫，捉到耗子的猫才是好猫。不过对于这个问题，我会在综合实验中做一个好的处理，提高它的效率，肯定不会去2次生成代码，不过我还需要自己去好好思考一下解决方案。需要更深的理解代码生成。

5.修改了一些PCode的内容，使opr 0 6改位取模运算，这也是使用PCode的好处，我可以自己去按照我自己的意思去设计运算的逻辑。

6.我还是说明一下一些部分的代码生成，拿if语句的生成做一个例子来说明：
if的语法：ifsym lparen cond rparen lbrace Stmt(1) rbrace Stmt(2)
那么我要生成的代码就是：
cond的目标代码
JPC L1
Stmt(1)的目标代码
L1
Stmt(2)的目标代码
这个逻辑就是这个样子的。比较容易理解。Stmt(1)是条件满足时要执行的if语句中的代码，而Stmt(2)则是与if语句并列的其他代码。

7.我的代码生成的代码存放在test文件中的wyc.PCode文件中，可供查看。

大致内容就是这些。
MadeBy SHvsMK
PB11011030
王一橙

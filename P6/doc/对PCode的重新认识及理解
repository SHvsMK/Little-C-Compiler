序：渐渐的进入了深夜，每次写报告的时候都有一种小小的忧伤，实验很快做完之后总是拖着最后来总结所写的所思考的东西，真不是一个好的习惯，太拖沓了。(小小的发点牢骚嘿嘿。)

因为我所使用的中间代码生成是用的PCode所以就需要对PCode有一个比较完整全面的理解，才能更好的去从所生成的语法树来生成中间代码。

下面我就说明一下我对PCode的理解。
上一次看PCode代码还是在分析pl0编译器的时候去了解的。当时对PCode的理解并不是特别的清楚，只是知道每一个指令都是有用的，具体的意义如何并不是非常清楚，下面我做一个大致的分析。
整个程序的执行是在一个栈上进行的，其实这样说并不准确，实际上可以说是分成两个部分，一个部分是存储代码的，一个部分是存储数据的，而这两个部分并不相交，而相互之间却有很大的联系。而我自己在看运行过程的时候，我更加关注的是数据栈的变化，因为这里面的变化直接就关系到了最后结果的正确性。而在实现过程中我所关注的东西却是不一样的，因为对于数据的处理是代码执行的一个结果，而我所需要实现的东西确实代码本身。仔细体会这里面的一个关系，其实很有意思。从我上面的分析可以看出来，我最需要关注的是数据的变化，也就是数据栈，但是我自己实现的确实代码段的内容，这其实从某种意义上是有一些矛盾的，如何将这两者联系起来，那就是深刻理解每条指令所被赋予的意义，也可以说对PCode解释器的理解。也许我所说的这些东西看上去是显而易见的，但是对我个人来说确实意义重大。因为这是我第一次这么清晰的认识到，对于一个语言理解好每条指令的意义对于运用这个语言是多么重要的一件事，因为之前写程序都是在集成开发环境下面操作的，遇上什么错误就可以去不停的调试，而现在在linux下调试相对来说并不是特别容易，而且我在自己生成中间代码的过程中的调试也是很麻烦的，要输出很多东西，有时候自己感觉代码应该像自己的想法一样执行，但却并不是这个样子的，这就是因为我对指令以及语言本身的理解并不深刻导致的，以至于我在实验过程中还尝试着自己去编写解释器，让解释器能够按照我的方式去处理程序，但是却越改越麻烦，最后还是静下来好好理解了每条指令以及语言本省的处理方式，最终完成了实验。下面开始说明PCode中的指令。
PCode里面只有8条指令，指令是非常少的，这也是我最初为什么要选择PCode的原因，因为少，必然不会太复杂。
指令格式为：FLA
其中F代表了指令的类型
LIT	将常数置于栈顶
LOD	将变量值置于栈顶
STO	将栈顶的值赋予某变量
CAL	用于过程调用的指令
INT	在数据栈中分配存储空间
JMP，JPC用于if，while语句的条件或无条件控制转移指令
OPR	一组算术或逻辑运算指令
L代表了指令的层次差(仅用于部分指令)
对于层次差我觉得需要好好的理解，因为这个在处理全局变量和临时变量的时候非常关键，因为这个层次差其实就像在引导访问链一样，只有有了这个参数，才能按照所需要的方式引用变量的值，这也是一个很容易出错的地方。因为C0和pl0不同，pl0可以在函数中定义函数，而C0却不允许这样的形式，所以对与层次差的理解我暂时是这样认为的，我在C0中规定最外层的层次为0，而只要进入了函数层次就变成1，这也就是说在C0中层次差只能是0或者1。所以这一点相对来说会比较好处理一些。这就是我对层次差的一个大体的看法。
A代表了一些参数，具体的指令对应着了不同的参数，这个就不再赘述了。
接下来需要去处理的就是C中的每一条语言所对应的PCode的一系列指令序列，这个在ast.c的Gen_P_Code函数中已经很详细的分析出了每一种语句或语法所对应的中间代码这里就不再一一说明了，因为我的语法设计是没有左递归的，所以语法相对来说更长一些，所以中间生成的代码也相对多一些，复杂一些，不过总的逻辑的结构和层次都是一样的。
下面我说一个很重要的东西，也是我在生成中间表达式所遇到的最大的问题。就是开空间的问题。我看了解释器的代码，发现它一开始给S[0,1,2]都赋值为0，而且是单独给他们赋值为0的，一开始的时候我并不是特别理解，觉得是这里面必然有一些需要存储的东西，但是并不是特别清楚，我就按照自己的理解，用多少空间开多少空间，也就是要用多少变量空间开多少。这样做之后，我发现了一个问题，每一次使用cal的时候，它会往栈顶上面的三个空间中存储一些临时信息，这些信息并不是变量数据的信息，而是一些返回之类的信息，其中包括返回地址，层次数，基址信息。这些信息都是非常有用的信息。所以如果我在开空间的时候不多开出3个空间，那么进入另一层的时候就会出现,如果有新的变量声明，那么就会将进入该函数时的返回信息给冲掉，这样我在运行完该函数之后，就无法正常的返回而出现错误，这是我在这个实验中所遇到的最大的问题，这也加深了我对返回链和访问链的更深一步的理解。还有一点就是解释器中访问变量的方式，它有一个base函数，是用来计算访问地址的，它的设计是有点像是在递归调用，很巧妙，我当时准备自己设计解释器时，也就是这个地方比较麻烦，所以对它的理解，也帮助我对以后要进行的扩展实验中添加数组有了更好的理解，就是该如果进行下标与空间地址的一个对应的理解。
以上就是我对PCode的一个重新的认识，以及我觉得重要的一些内容的一个说明，我觉得只有当把这些东西充分理解好了之后，再去生成PCode的中间代码，才会更加的游刃有余。
MadeBy SHvsMK
PB11011030
王一橙
